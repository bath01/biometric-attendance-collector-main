import logging
from datetime import datetime, timedelta
import requests
from zk import ZK as ZK_MANAGER
from models import Borne, app
from const import URL

logging = logging.getLogger(__file__)

def send_all_datas(datas, output=URL):
    """
    Envoie des donnees de la borne au backend
    """
    url = URL
    headers = {"content-type": "application/json"}
    body = {"params": {"data_list": datas}}
    try:
        result = requests.post(url, json=body, headers=headers)
        logging.error(str(result.text))
        return result.text
    except Exception as E:
        logging.error(str(E))

def get_all_datas():
    with app.app_context():
        logging.error(f"STARTING...{datetime.now().strftime('%d/%m/%Y %H:%M:%S')}")
        all_bornes = Borne.query.all()
        logging.error(f"all_bornes...{all_bornes}")
        emplacement = {"entree": "entree", "sortie": "sortie"}
        borne_connection = None
        
        # Définir la période de récupération des données
        start_date = datetime(2024, 1, 1)
        end_date = datetime(2024, 10, 13)
        
        for borne in all_bornes:
            logging.error(f"{borne.emplacement} => {borne.adresse_ip}")
       
            adresseip = borne.adresse_ip
            _emplacement = emplacement.get(borne.emplacement)
            if not _emplacement: continue
            current_borne_datas = []
            
            zk = ZK_MANAGER(
                borne.adresse_ip,
                port=borne.port,
                timeout=10, password=0,
                force_udp=False,
                ommit_ping=True
            )
            try:
                borne_connection = zk.connect()
                borne_connection.enable_device()
                if borne_connection:
                    attendance = borne_connection.get_attendance()
                    for each in attendance:
                        pointage_date = each.timestamp.date()
                        
                        # Vérifier si la date de pointage est dans la plage souhaitée
                        if start_date.date() <= pointage_date <= end_date.date():
                            atten_time = each.timestamp.strftime("%Y-%m-%d %H:%M:%S")
                            new_datas = {
                                "check_in_out": _emplacement,
                                "user_id": each.user_id,
                                "pointage_time": atten_time,
                                "atten_time": atten_time,
                                "pointage_heur": each.timestamp.hour + each.timestamp.minute / 60,
                                "pointage_date": pointage_date.strftime("%Y-%m-%d"),
                                "adresse_ip": adresseip
                            }
                            current_borne_datas.append(new_datas)
                    
                    send_all_datas(current_borne_datas, output=borne.out_put)
                    logging.error(f"{len(current_borne_datas)} Enregistrements envoyes...")
                else:
                    logging.info(f"Connection Error {borne_connection}")
            except Exception as error:
                logging.error(str(error))
            finally:
                if borne_connection:
                    try:
                        borne_connection.disconnect()
                    except Exception as error:
                        logging.error(str(error))